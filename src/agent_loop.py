"""Agent loop system for DevCrew Agents with Reason → Act → Output cycle."""

import os
import time
import json
import logging
from datetime import datetime
from typing import Dict, Any, List, Optional, Tuple
from enum import Enum
from dataclasses import dataclass, asdict
from crewai import Agent
from crewai.llm import LLM

from communication import (
    SharedMemoryManager,
    MessageBus,
    MessagePriority,
    KnowledgeStore
)


class AgentState(Enum):
    """Agent execution states."""
    IDLE = "idle"
    REASONING = "reasoning"
    ACTING = "acting"
    OUTPUTTING = "outputting"
    ERROR = "error"
    COMPLETE = "complete"


class ActionType(Enum):
    """Types of actions an agent can take."""
    TOOL_CALL = "tool_call"
    MESSAGE_SEND = "message_send"
    FILE_UPDATE = "file_update"
    MEMORY_UPDATE = "memory_update"
    KNOWLEDGE_ADD = "knowledge_add"
    DECISION = "decision"


@dataclass
class ReasoningStep:
    """Individual reasoning step in the agent's thought process."""
    step_number: int
    thought: str
    confidence: float
    alternatives: List[str]
    timestamp: str


@dataclass
class AgentAction:
    """Action taken by an agent."""
    action_type: ActionType
    target: str
    content: Any
    metadata: Dict[str, Any]
    timestamp: str
    success: bool = False
    result: Any = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with enum serialization."""
        data = asdict(self)
        data['action_type'] = self.action_type.value
        return data


@dataclass
class AgentOutput:
    """Output generated by an agent."""
    agent_id: str
    task_id: str
    content: str
    reasoning_chain: List[ReasoningStep]
    actions_taken: List[AgentAction]
    final_state: AgentState
    execution_time: float
    timestamp: str

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with enum serialization."""
        data = asdict(self)
        data['final_state'] = self.final_state.value
        data['actions_taken'] = [action.to_dict()
                                 for action in self.actions_taken]
        return data


class AgentLoop:
    """Individual agent execution loop with Reason → Act → Output cycle."""

    def __init__(self, agent_id: str, model_name: str, tools: List = None):
        self.agent_id = agent_id
        self.model_name = model_name
        self.tools = tools or []
        self.state = AgentState.IDLE
        self.current_task = None

        # Communication components
        self.memory = SharedMemoryManager(f"agent_{agent_id}_memory.db")
        self.message_bus = MessageBus(f"agent_{agent_id}_messages.db")
        self.knowledge = None
        try:
            self.knowledge = KnowledgeStore(f"./agent_{agent_id}_kb")
        except ImportError:
            logging.warning(f"ChromaDB not available for agent {agent_id}")

        # Execution tracking
        self.reasoning_steps: List[ReasoningStep] = []
        self.actions_taken: List[AgentAction] = []
        self.start_time = None

        # Initialize LLM with agent-specific model
        self.llm = LLM(
            model=model_name,
            temperature=self._get_agent_temperature(),
            max_tokens=2000
        )

        # Setup logging
        self.logger = self._setup_logging()

    def _get_agent_temperature(self) -> float:
        """Get temperature setting based on agent type."""
        temperature_map = {
            "project_manager": 0.2,
            "designer": 0.4,
            "coder": 0.3,
            "tester": 0.25
        }
        return temperature_map.get(self.agent_id, 0.3)

    def _setup_logging(self) -> logging.Logger:
        """Setup agent-specific logging."""
        logger = logging.getLogger(f"agent_{self.agent_id}")
        logger.setLevel(logging.INFO)

        if not logger.handlers:
            handler = logging.FileHandler(f"agent_{self.agent_id}.log")
            formatter = logging.Formatter(
                '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
            )
            handler.setFormatter(formatter)
            logger.addHandler(handler)

        return logger

    def execute(self, task: Dict[str, Any]) -> AgentOutput:
        """Execute the main agent loop: Reason → Act → Output."""
        self.start_time = time.time()
        self.current_task = task
        self.state = AgentState.REASONING
        task_id = task.get('id', f"task_{int(time.time())}")

        self.logger.info(f"Starting execution for task: {task_id}")

        try:
            # Phase 1: Reasoning
            reasoning_result = self._reason(task)

            # Phase 2: Acting
            if reasoning_result:
                self.state = AgentState.ACTING
                action_results = self._act(reasoning_result)

            # Phase 3: Output
            self.state = AgentState.OUTPUTTING
            output = self._generate_output(task_id)

            self.state = AgentState.COMPLETE
            return output

        except Exception as e:
            self.state = AgentState.ERROR
            self.logger.error(f"Error in agent loop: {str(e)}")
            return self._generate_error_output(task_id, str(e))

    def _reason(self, task: Dict[str, Any]) -> Dict[str, Any]:
        """Reasoning phase - analyze task and plan actions."""
        self.logger.info("Starting reasoning phase")

        reasoning_prompt = self._build_reasoning_prompt(task)
        max_steps = int(os.getenv('MAX_REASONING_STEPS', 10))

        for step in range(max_steps):
            try:
                # Get reasoning from LLM
                response = self.llm.call(reasoning_prompt)

                # Parse reasoning step
                reasoning_step = self._parse_reasoning_step(step, response)
                self.reasoning_steps.append(reasoning_step)

                # Check if reasoning is complete
                if self._is_reasoning_complete(reasoning_step):
                    break

                # Update prompt for next iteration
                reasoning_prompt = self._update_reasoning_prompt(
                    reasoning_prompt, reasoning_step)

            except Exception as e:
                self.logger.error(f"Error in reasoning step {step}: {str(e)}")
                break

        return self._extract_action_plan()

    def _build_reasoning_prompt(self, task: Dict[str, Any]) -> str:
        """Build the initial reasoning prompt for the agent."""
        context = self._gather_context()

        prompt = f"""
You are {self.agent_id} working on the following task:
{json.dumps(task, indent=2)}

Current Context:
{context}

Your role is to reason through this task step by step:
1. Understand what needs to be done
2. Identify available resources and tools
3. Plan the sequence of actions
4. Consider potential obstacles and alternatives
5. Make a decision on the best approach

Think step by step and provide your reasoning in the following format:
THOUGHT: [Your current thinking]
CONFIDENCE: [0.0-1.0 confidence level]
ALTERNATIVES: [Other approaches you considered]
NEXT_ACTION: [What you plan to do next, or COMPLETE if done reasoning]

Begin your reasoning:
"""
        return prompt

    def _gather_context(self) -> str:
        """Gather relevant context for reasoning."""
        context_parts = []

        # Get recent messages
        messages = self.message_bus.get_messages(self.agent_id, limit=5)
        if messages:
            context_parts.append(f"Recent messages: {len(messages)} items")

        # Get memory keys
        memory_keys = self.memory.list_keys()
        if memory_keys:
            context_parts.append(
                f"Available memory: {', '.join(memory_keys[:10])}")

        # Get knowledge if available
        if self.knowledge:
            stats = self.knowledge.get_stats()
            if stats.get('total_knowledge_items', 0) > 0:
                context_parts.append(
                    f"Knowledge items: {stats['total_knowledge_items']}")

        return "; ".join(context_parts) if context_parts else "No additional context"

    def _parse_reasoning_step(self, step_number: int, response: str) -> ReasoningStep:
        """Parse LLM response into structured reasoning step."""
        lines = response.strip().split('\n')
        thought = ""
        confidence = 0.5
        alternatives = []

        for line in lines:
            line = line.strip()
            if line.startswith('THOUGHT:'):
                thought = line[8:].strip()
            elif line.startswith('CONFIDENCE:'):
                try:
                    confidence = float(line[11:].strip())
                except:
                    confidence = 0.5
            elif line.startswith('ALTERNATIVES:'):
                alt_text = line[13:].strip()
                alternatives = [alt.strip()
                                for alt in alt_text.split(',') if alt.strip()]

        return ReasoningStep(
            step_number=step_number,
            thought=thought or response[:200],
            confidence=confidence,
            alternatives=alternatives,
            timestamp=datetime.now().isoformat()
        )

    def _is_reasoning_complete(self, step: ReasoningStep) -> bool:
        """Check if reasoning is complete."""
        return (
            step.confidence > 0.8 or
            "COMPLETE" in step.thought.upper() or
            "NEXT_ACTION: COMPLETE" in step.thought.upper()
        )

    def _update_reasoning_prompt(self, current_prompt: str, step: ReasoningStep) -> str:
        """Update reasoning prompt with latest step."""
        return f"{current_prompt}\n\nStep {step.step_number}: {step.thought}\n\nContinue reasoning:"

    def _extract_action_plan(self) -> Dict[str, Any]:
        """Extract action plan from reasoning steps."""
        if not self.reasoning_steps:
            return {"actions": []}

        last_step = self.reasoning_steps[-1]

        # Simple action extraction - in production, this would be more sophisticated
        action_plan = {
            "primary_action": self._identify_primary_action(last_step.thought),
            "confidence": last_step.confidence,
            "reasoning_summary": last_step.thought,
            "actions": self._identify_specific_actions(last_step.thought)
        }

        return action_plan

    def _identify_primary_action(self, thought: str) -> ActionType:
        """Identify the primary action type from reasoning."""
        thought_lower = thought.lower()

        if any(word in thought_lower for word in ['tool', 'execute', 'run']):
            return ActionType.TOOL_CALL
        elif any(word in thought_lower for word in ['message', 'send', 'notify']):
            return ActionType.MESSAGE_SEND
        elif any(word in thought_lower for word in ['file', 'write', 'create', 'update']):
            return ActionType.FILE_UPDATE
        elif any(word in thought_lower for word in ['remember', 'store', 'memory']):
            return ActionType.MEMORY_UPDATE
        elif any(word in thought_lower for word in ['knowledge', 'learn', 'document']):
            return ActionType.KNOWLEDGE_ADD
        else:
            return ActionType.DECISION

    def _identify_specific_actions(self, thought: str) -> List[Dict[str, Any]]:
        """Identify specific actions to take."""
        # This is a simplified version - would be more sophisticated in production
        actions = []

        if "tool" in thought.lower():
            actions.append({
                "type": "tool_call",
                "description": "Execute tool based on reasoning"
            })

        if "message" in thought.lower():
            actions.append({
                "type": "message_send",
                "description": "Send message to team"
            })

        return actions

    def _act(self, action_plan: Dict[str, Any]) -> List[AgentAction]:
        """Acting phase - execute planned actions."""
        self.logger.info("Starting acting phase")
        results = []

        for action_desc in action_plan.get('actions', []):
            try:
                action = self._execute_action(action_desc, action_plan)
                results.append(action)
                self.actions_taken.append(action)

                # Add delay for sandbox safety
                time.sleep(0.1)

            except Exception as e:
                self.logger.error(f"Error executing action: {str(e)}")
                error_action = AgentAction(
                    action_type=ActionType.DECISION,
                    target="error_handler",
                    content=f"Failed to execute action: {str(e)}",
                    metadata={"error": str(e)},
                    timestamp=datetime.now().isoformat(),
                    success=False
                )
                results.append(error_action)

        return results

    def _execute_action(self, action_desc: Dict[str, Any], plan: Dict[str, Any]) -> AgentAction:
        """Execute a specific action."""
        action_type = ActionType(action_desc.get('type', 'decision'))
        timestamp = datetime.now().isoformat()

        if action_type == ActionType.TOOL_CALL:
            return self._execute_tool_call(action_desc, timestamp)
        elif action_type == ActionType.MESSAGE_SEND:
            return self._execute_message_send(action_desc, timestamp)
        elif action_type == ActionType.MEMORY_UPDATE:
            return self._execute_memory_update(action_desc, timestamp)
        elif action_type == ActionType.KNOWLEDGE_ADD:
            return self._execute_knowledge_add(action_desc, timestamp)
        else:
            return self._execute_decision(action_desc, plan, timestamp)

    def _execute_tool_call(self, action_desc: Dict[str, Any], timestamp: str) -> AgentAction:
        """Execute a tool call action."""
        # Simplified tool execution - would integrate with actual tools
        result = f"Tool execution simulated for {self.agent_id}"

        return AgentAction(
            action_type=ActionType.TOOL_CALL,
            target="tool_system",
            content=action_desc,
            metadata={"agent_id": self.agent_id},
            timestamp=timestamp,
            success=True,
            result=result
        )

    def _execute_message_send(self, action_desc: Dict[str, Any], timestamp: str) -> AgentAction:
        """Execute a message send action."""
        message_content = {
            "from": self.agent_id,
            "message": action_desc.get('description', 'Action completed'),
            "timestamp": timestamp
        }

        # Send to team communication channel
        msg_id = self.message_bus.broadcast_message(
            sender_id=self.agent_id,
            channel="team_updates",
            content=message_content,
            subject=f"Update from {self.agent_id}",
            priority=MessagePriority.NORMAL
        )

        return AgentAction(
            action_type=ActionType.MESSAGE_SEND,
            target="team_updates",
            content=message_content,
            metadata={"message_id": msg_id},
            timestamp=timestamp,
            success=bool(msg_id),
            result=msg_id
        )

    def _execute_memory_update(self, action_desc: Dict[str, Any], timestamp: str) -> AgentAction:
        """Execute a memory update action."""
        key = f"action_result_{int(time.time())}"
        value = {
            "action": action_desc,
            "agent": self.agent_id,
            "timestamp": timestamp
        }

        success = self.memory.set(key, value, self.agent_id)

        return AgentAction(
            action_type=ActionType.MEMORY_UPDATE,
            target=key,
            content=value,
            metadata={"key": key},
            timestamp=timestamp,
            success=success,
            result=key if success else None
        )

    def _execute_knowledge_add(self, action_desc: Dict[str, Any], timestamp: str) -> AgentAction:
        """Execute a knowledge addition action."""
        if not self.knowledge:
            return AgentAction(
                action_type=ActionType.KNOWLEDGE_ADD,
                target="knowledge_store",
                content="ChromaDB not available",
                metadata={},
                timestamp=timestamp,
                success=False,
                result="ChromaDB not available"
            )

        content = f"Action taken: {action_desc.get('description', 'Unknown action')}"
        k_id = self.knowledge.add_knowledge(
            content=content,
            agent_id=self.agent_id,
            category="actions",
            tags=["agent_loop", "action"]
        )

        return AgentAction(
            action_type=ActionType.KNOWLEDGE_ADD,
            target="knowledge_store",
            content=content,
            metadata={"knowledge_id": k_id},
            timestamp=timestamp,
            success=bool(k_id),
            result=k_id
        )

    def _execute_decision(self, action_desc: Dict[str, Any], plan: Dict[str, Any], timestamp: str) -> AgentAction:
        """Execute a decision action."""
        decision = {
            "decision": action_desc.get('description', 'Decision made'),
            "reasoning": plan.get('reasoning_summary', 'No reasoning provided'),
            "confidence": plan.get('confidence', 0.5)
        }

        return AgentAction(
            action_type=ActionType.DECISION,
            target="decision_log",
            content=decision,
            metadata={"agent_id": self.agent_id},
            timestamp=timestamp,
            success=True,
            result=decision
        )

    def _generate_output(self, task_id: str) -> AgentOutput:
        """Generate final output for the agent execution."""
        execution_time = time.time() - self.start_time if self.start_time else 0

        # Generate summary content
        content = self._generate_output_content()

        output = AgentOutput(
            agent_id=self.agent_id,
            task_id=task_id,
            content=content,
            reasoning_chain=self.reasoning_steps,
            actions_taken=self.actions_taken,
            final_state=self.state,
            execution_time=execution_time,
            timestamp=datetime.now().isoformat()
        )

        # Store output in memory for other agents (with proper serialization)
        self.memory.set(f"output_{task_id}", output.to_dict(), self.agent_id)

        self.logger.info(f"Generated output for task {task_id}")
        return output

    def _generate_output_content(self) -> str:
        """Generate the main content of the output."""
        content_parts = [
            f"# {self.agent_id.title()} Agent Output",
            "",
            f"**Task completed at:** {datetime.now().isoformat()}",
            f"**Reasoning steps:** {len(self.reasoning_steps)}",
            f"**Actions taken:** {len(self.actions_taken)}",
            "",
            "## Reasoning Summary",
        ]

        if self.reasoning_steps:
            for step in self.reasoning_steps[-3:]:  # Last 3 steps
                content_parts.append(
                    f"- Step {step.step_number}: {step.thought[:100]}...")

        content_parts.extend([
            "",
            "## Actions Completed",
        ])

        for action in self.actions_taken:
            status = "✅" if action.success else "❌"
            content_parts.append(
                f"- {status} {action.action_type.value}: {action.target}")

        return "\n".join(content_parts)

    def _generate_error_output(self, task_id: str, error: str) -> AgentOutput:
        """Generate error output when execution fails."""
        execution_time = time.time() - self.start_time if self.start_time else 0

        return AgentOutput(
            agent_id=self.agent_id,
            task_id=task_id,
            content=f"# Error in {self.agent_id} Agent\n\n**Error:** {error}",
            reasoning_chain=self.reasoning_steps,
            actions_taken=self.actions_taken,
            final_state=AgentState.ERROR,
            execution_time=execution_time,
            timestamp=datetime.now().isoformat()
        )
